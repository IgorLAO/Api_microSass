"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = exports.Driver = exports.Internals = void 0;
const knex_1 = __importDefault(require("knex"));
const knex_schema_inspector_1 = __importDefault(require("knex-schema-inspector"));
const node_crypto_1 = require("node:crypto");
var Internals;
(function (Internals) {
    function context(c) {
        const context = this.queryContext() ?? Object.create(null);
        if (context._userContext === undefined) {
            context._userContext = Object.create(null);
        }
        if (c === undefined) {
            return context._userContext;
        }
        context._userContext = c;
        return this.queryContext(context);
    }
    Internals.context = context;
    function includeOne(table, type, s) {
        const t = this;
        const context = t.queryContext() ?? Object.create(null);
        if (context._joins === undefined) {
            context._joins = [];
        }
        context._joins.push(table);
        const q = t.queryContext(context);
        switch (type) {
            case 'CROSS JOIN':
                return q.crossJoin(table, s);
                break;
            case 'FULL OUTER JOIN':
                return q.fullOuterJoin(table, s);
                break;
            case 'INNER JOIN':
                return q.innerJoin(table, s);
                break;
            case 'JOIN':
                return q.join(table, s);
                break;
            case 'LEFT JOIN':
                return q.leftJoin(table, s);
                break;
            case 'LEFT OUTER JOIN':
                return q.leftOuterJoin(table, s);
                break;
            case 'OUTER JOIN':
                return q.outerJoin(table, s);
                break;
            case 'RIGHT JOIN':
                return q.rightJoin(table, s);
                break;
        }
    }
    Internals.includeOne = includeOne;
    function getConnTable(table, trxName) {
        let conn = this.table(table);
        if (trxName !== undefined && conn.comment !== undefined) {
            conn = conn.comment(`TRX: ${trxName}`);
        }
        return conn;
    }
    Internals.getConnTable = getConnTable;
})(Internals || (exports.Internals = Internals = {}));
class Driver {
    config;
    inTransaction;
    conn;
    trxConn;
    cacheTable;
    logQuerys;
    trxName;
    constructor(config, inTransaction, trx, cacheTable) {
        this.inTransaction = inTransaction;
        this.config = config;
        this.logQuerys = Plata.config.ENV === 'debug' || Plata.config._PLATA_SQL_SHOWQUERY === '1';
        if (!this.inTransaction) {
            if (config.pool === undefined)
                config.pool = {
                    min: 1,
                    max: 1
                };
            if (!Plata._knexExtended) {
                knex_1.default.QueryBuilder.extend('context', Internals.context);
                knex_1.default.QueryBuilder.extend('includeOne', Internals.includeOne);
                knex_1.default.QueryBuilder.extend('getConnTable', Internals.getConnTable);
                Plata._knexExtended = true;
            }
            const trxPool = {
                min: 1,
                max: 1
            };
            if (Plata.config.__PLATA_SQL_TRX_MIN_POOL) {
                trxPool.min = +Plata.config.__PLATA_SQL_TRX_MIN_POOL;
            }
            if (Plata.config.__PLATA_SQL_TRX_MAX_POOL) {
                trxPool.max = +Plata.config.__PLATA_SQL_TRX_MAX_POOL;
            }
            this.conn = (0, knex_1.default)(config);
            this.trxConn = (0, knex_1.default)({
                ...config,
                pool: trxPool
            });
        }
        else {
            this.conn = trx;
            this.trxConn = trx;
        }
        this.trxName = this.conn?.userParams?.trxName;
        if (this.logQuerys) {
            this.conn.on('query', (...args) => console.log(...args));
            this.conn.on('query-error', (...args) => console.error(...args));
        }
        this.cacheTable = cacheTable ?? new Map();
    }
    async onOpenTrx(trx) {
        return trx;
    }
    runRawWithComment(query) {
        if (this.trxName === undefined) {
            return this.conn.raw(query.sql, query.bindings);
        }
        return this.conn.raw(`/*TRX: ${this.trxName}*/${query.sql}`, query.bindings);
    }
    select(table, model) {
        return {
            build: (builder) => new Query(builder(this.conn.queryBuilder().getConnTable(table, this.trxName)), model, table),
        };
    }
    async rawMappedSelect(queryInfo) {
        let queryBuilder = this.conn.queryBuilder().from(queryInfo.table);
        const validades = new Set();
        for (const col in queryInfo.cols) {
            queryBuilder = queryInfo.cols[col][0](queryBuilder);
            if (queryInfo.cols[col][2] === 'required') {
                validades.add(col);
            }
        }
        const sql = queryInfo.query(queryBuilder, {}).toSQL();
        const result = await this.runRawWithComment(sql).then(r => r, err => ({
            errorID: 'PLSQLRWSEL001',
            msg: 'Unexpected error while select',
            error: {
                message: err?.toString(),
                stack: new Error().stack
            },
        }));
        if (result.errorID !== undefined) {
            return result;
        }
        if (validades.size !== 0) {
            for (let i = 0; i < result.length; i++) {
                const row = result[i];
                for (const col of validades) {
                    if (row[col] === null || row[col] === undefined) {
                        return {
                            errorID: 'PLSQLRWSEL002',
                            msg: 'Not valid select',
                            error: {
                                message: `${col} is NULL`,
                                stack: new Error().stack
                            },
                        };
                    }
                }
            }
        }
        return result;
    }
    async insert(table, model, values, options) {
        if (this.config.client === 'mssql') {
            const sql = this.conn.queryBuilder().getConnTable(table, this.trxName).insert(values, '*', {
                includeTriggerModifications: options?.ignoreTrigger === undefined
            }).toSQL();
            return this.runRawWithComment(sql).then(r => r, err => Plata.BuildPlataError({
                errorID: 'PLSQL001',
                msg: 'Unexpected error while inserting',
                error: {
                    message: err?.toString(),
                    stack: new Error().stack
                },
            }));
        }
        if (options?.ignoreTrigger === true)
            return this.conn.queryBuilder().getConnTable(table, this.trxName).insert(values, '*', {
                includeTriggerModifications: options?.ignoreTrigger
            }).then(r => r, err => Plata.BuildPlataError({
                errorID: 'PLSQLINS001',
                msg: 'Unexpected error while inserting',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                },
            }));
        const key = await (0, knex_schema_inspector_1.default)(this.conn).primary(table).then(r => {
            if (r === null) {
                return Plata.BuildPlataError({
                    errorID: 'PLSQL007',
                    msg: 'Tabela não tem chave primária'
                });
            }
            return r;
        }, err => Plata.BuildPlataError({
            errorID: 'PLSQL006',
            msg: 'Erro ao consultar a chave primária da tabela',
            error: {
                message: err?.toString(),
                stack: err?.stack ?? new Error().stack
            }
        }));
        if (key.errorID !== undefined) {
            return key;
        }
        return this.transaction(async (trx) => {
            const result = await trx.conn.queryBuilder().getConnTable(table, `${trx.trxName}<->${this.trxName}`).insert(values);
            return trx.conn.select('*').from(table).whereIn(key, result);
        });
    }
    update(table, model) {
        return {
            build: async (s, set) => {
                const sql = s(this.conn.queryBuilder().getConnTable(table, this.trxName)).update(set).toSQL();
                return this.runRawWithComment(sql).then(() => true, err => Plata.BuildPlataError({
                    errorID: 'PLSQL002',
                    msg: 'Unexpected error while update',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                }));
            },
        };
    }
    log(text, ...extras) {
        if (this.logQuerys === true) {
            console.log(text, ...extras);
        }
    }
    trasation(transaction, config) {
        return this.conn.transaction(async (trx) => {
            const transactionDriver = new Driver(this.config, true, trx, this.cacheTable);
            const result = await transaction(transactionDriver);
            return result;
        }, config).then(r => r, err => {
            if (!err) {
                err = Object.create(null);
            }
            err.originalError = undefined;
            return Plata.BuildPlataError({
                errorID: 'PLSQL003',
                msg: 'Unexpected error in transation',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                },
            });
        });
    }
    async getTransactionDriver(config) {
        const trxName = (0, node_crypto_1.randomUUID)();
        const provider = await this.trxConn.transactionProvider({
            ...config,
            doNotRejectOnRollback: true,
        });
        this.log(`[PLATA-SQL] [TRX-${trxName}] - Inciando provider`);
        const trx = await provider().catch(e => ({
            errorID: 'PLSQLGETTRX001',
            msg: 'Erro ao iniciar a transação',
            error: {
                message: e?.toString(),
                stack: e?.stack ?? new Error().stack,
                trxName
            }
        }));
        if (trx.errorID !== undefined) {
            this.log(`[PLATA-SQL] [TRX-${trxName}] - Conexão  não foi aberta - ${JSON.stringify(trx)}`);
            return trx;
        }
        trx.userParams.trxName = trxName;
        this.log(`[PLATA-SQL] [TRX-${trxName}] - Conexão foi aberta`);
        return this.onOpenTrx(new Driver(this.config, true, trx, this.cacheTable));
    }
    async transaction(transaction, config) {
        const driver = await this.getTransactionDriver(config);
        if (driver.errorID !== undefined) {
            return driver;
        }
        const transPromise = Plata.FastPromise(() => driver.conn.executionPromise.catch((...args) => console.log(...args)));
        try {
            const resultTransation = await transaction(driver);
            if (resultTransation.errorID !== undefined) {
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback -> Erro da API na transação - ${JSON.stringify(resultTransation)}`);
                await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err));
                await transPromise;
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback realizado`);
                return resultTransation;
            }
            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Commit -> Realizando Commit`);
            const resultCommit = await driver.conn.commit().then(() => true, err => ({
                errorID: 'PLSQLTRX003',
                msg: 'Erro inesperado ao realizar o commit',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            }));
            if (resultCommit.errorID !== undefined) {
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Erro no commit, realizando Rollback`);
                await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err));
                await transPromise;
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback realizado`);
                return resultCommit;
            }
            await transPromise;
            return resultTransation;
        }
        catch (err) {
            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Erro inesperado: `, err);
            await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err));
            await transPromise;
            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Roollback realizado`);
            return {
                errorID: 'PLSQLTRX002',
                msg: 'Erro inesperado ao realizar a transação ',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            };
        }
    }
    async getColumns(table) {
        if (Plata.config._PLATA_SQL_CACHETABLE !== '1')
            return this.getColumsBanco(table);
        const cache = this.cacheTable.get(table);
        if (cache === undefined) {
            const result = await this.getColumsBanco(table);
            if (result.errorID !== undefined) {
                return result;
            }
            this.cacheTable.set(table, {
                coluns: result,
                date: new Date()
            });
            return result;
        }
        const ttl = (+(Plata.config._PLATA_SQL_CACHETABLETIME || 60) || 60) * 60 * 1000;
        if ((new Date().getTime() - cache.date.getTime()) > ttl) {
            const result = await this.getColumsBanco(table);
            if (result.errorID !== undefined) {
                return result;
            }
            this.cacheTable.set(table, {
                coluns: result,
                date: new Date()
            });
            return result;
        }
        return cache.coluns;
    }
    async getColumsBanco(table) {
        return this.conn(table).columnInfo().catch(err => Plata.BuildPlataError({
            errorID: 'PLSQL004',
            msg: 'Erro ao consultar a estrutura da tabela',
            error: {
                message: err?.toString(),
                stack: err?.stack ?? new Error().stack
            }
        }));
    }
    getDefaultValue(type, value) {
        if (value !== null) {
            return value;
        }
        switch (type) {
            case 'image':
                return '';
            case 'int':
            case 'integer':
                return 0;
            case 'datetime2':
                return null;
            case 'decimal':
                return 0;
            case 'varbinary':
                return '';
            case 'text':
                return '';
            case 'smallint':
                return 0;
            case 'datetimeoffset':
                return 0;
            case 'varchar':
                return '';
            case 'binary':
                return 0;
            case 'datetime':
                return null;
            case 'time':
                return null;
            case 'numeric':
                return 0;
            case 'uniqueidentifier':
                return 0;
            case 'tinyint':
                return 0;
            case 'nchar':
                return '';
            case 'smalldatetime':
                return null;
            case 'float':
                return 0;
            case 'date':
                return null;
            case 'char':
                return '';
            case 'bigint':
                return 0;
            case 'nvarchar':
                return '';
            case 'sysname':
                return '';
            case 'bit':
                return 0;
            default:
                return '';
        }
    }
    async autoInsert(table, model, values, ignore, options) {
        const columns = await this.getColumns(table);
        if (columns.errorID !== undefined) {
            return columns;
        }
        const newValues = [];
        for (let i = 0; i < values.length; i++) {
            const v = Object.create(null);
            for (const key in values[i]) {
                v[key.toUpperCase()] = values[i][key];
            }
            const insertValues = Object.create(null);
            for (const key in columns) {
                const n = key.toUpperCase();
                if (ignore.find(c => c.toString().toUpperCase() === n) !== undefined) {
                    continue;
                }
                const value = this.getDefaultValue(columns[key].type.toLowerCase(), v[n] ?? null);
                if (value === null) {
                    continue;
                }
                insertValues[n] = value;
            }
            newValues.push(insertValues);
        }
        const inserted = await this.insert(table, {}, newValues, options);
        if (inserted.errorID !== undefined) {
            return inserted;
        }
        const insertedRows = [];
        for (let i = 0; i < inserted.length; i++) {
            const item = inserted[i];
            const insertedRow = Object.create(null);
            for (const key in item) {
                insertedRow[key.toUpperCase()] = item[key];
            }
            insertedRows.push(insertedRow);
        }
        return insertedRows;
    }
}
exports.Driver = Driver;
class Query {
    query;
    model;
    table;
    joins;
    constructor(query, model, table) {
        const context = query.queryContext() ?? Object.create(null);
        this.joins = context._joins ?? [];
        this.table = table;
        this.model = model;
        this.query = this._buildSelect(query, this.model.template);
    }
    _buildSelect(query, template) {
        const cs = [];
        for (const key in template) {
            if (!Array.isArray(template[key])) {
                continue;
            }
            if (Array.isArray(template[key][0])) {
                continue;
            }
            if (typeof template[key][0] === 'function') {
                cs.push(`${this.table}.${key} as ${this.table}_${key}`);
                continue;
            }
            if (!this.joins.includes(key)) {
                continue;
            }
            for (const column in template[key][0]) {
                cs.push(`${key}.${column} as ${key}_${column}`);
            }
        }
        return query.select(...cs);
    }
    _buildModel(row) {
        const template = this.model.template;
        const r = Object.create(null);
        for (const key in template) {
            if (!Array.isArray(template[key])) {
                continue;
            }
            if (Array.isArray(template[key][0])) {
                r[key] = [];
                continue;
            }
            if (typeof template[key][0] === 'function') {
                r[key] = row[`${this.table}_${key}`] ?? null;
                continue;
            }
            if (!this.joins.includes(key)) {
                r[key] = [];
                continue;
            }
            r[key] = [Object.create(null)];
            for (const column in template[key][0]) {
                r[key][0][column] = row[`${key}_${column}`] ?? null;
            }
        }
        return r;
    }
    _handleStream(handler) {
        return new Promise(resolve => {
            let shoudContinue = true;
            const stream = this.query.stream();
            stream.on('close', async () => {
                return resolve(handler.close());
            });
            stream.on('data', async (row) => {
                if (shoudContinue) {
                    shoudContinue = await handler.row(this._buildModel(row));
                }
                else {
                    stream.pause();
                }
            });
            stream.on('pause', () => {
                stream.destroy();
            });
            stream.on('error', async (err) => {
                shoudContinue = false;
                if (handler.error !== undefined)
                    await handler.error(err);
                return resolve({
                    errorID: 'PLSQLQ001',
                    msg: 'Unexpected error in query',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                });
            });
        });
    }
    async toListAsync() {
        const errors = [];
        const itens = [];
        const result = await this.query.then(r => {
            const promises = [];
            for (let i = 0; i < r.length; i++) {
                promises.push(Plata.FastPromise(async () => {
                    const v = await this.model.validate(this._buildModel(r[i]));
                    if (v.errors !== undefined) {
                        errors.push(...v.errors);
                    }
                    itens.push(v.value);
                    return true;
                }));
            }
            return Promise.all(promises);
        }, err => Plata.BuildPlataError({
            errorID: 'PLSQLQ005',
            msg: 'Erro ao execultar a query',
            error: {
                message: err?.toString(),
                stack: err?.stack ?? new Error().stack
            }
        }));
        if (result.errorID !== undefined) {
            return result;
        }
        if (errors.length !== 0) {
            return {
                errors,
                itens,
            };
        }
        return {
            errors: undefined,
            itens,
        };
    }
    async eachRowAsync(c) {
        const promises = [];
        let shoudContinue = true;
        let error = undefined;
        return this._handleStream({
            row: async (row) => {
                promises.push(Plata.FastPromise(() => this.model.validate(row))
                    .then(lineResult => {
                    c(lineResult).then(r => {
                        if (r.errorID !== undefined) {
                            shoudContinue = false;
                            error = r;
                            return;
                        }
                        shoudContinue = shoudContinue ? r : shoudContinue;
                    });
                })
                    .catch(err => {
                    shoudContinue = false;
                    error = {
                        errorID: 'PLSQLQ003',
                        msg: 'Unexpected error in callback',
                        error: {
                            message: err?.toString(),
                            stack: err?.stack ?? new Error().stack
                        }
                    };
                }));
                return shoudContinue;
            },
            close: async () => {
                return Promise.all(promises).then(() => error ?? true, err => Plata.BuildPlataError({
                    errorID: 'PLSQLQ004',
                    msg: 'Unexpected Error in select',
                    error: err
                }));
            }
        });
    }
}
exports.Query = Query;
//# sourceMappingURL=sql.js.map