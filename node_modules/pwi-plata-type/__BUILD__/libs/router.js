"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Internals = void 0;
exports.processRoutes = processRoutes;
exports.loadRoutesFromProject = loadRoutesFromProject;
exports.buildExpressRouter = buildExpressRouter;
const node_path_1 = __importDefault(require("node:path"));
const custom_1 = require("./custom");
var Internals;
(function (Internals) {
    function buildRouterObject(fileRoute) {
        const router = {
            routes: [],
            swaggerHide: false,
            httpRoute: fileRoute,
            mark: Object.create(null)
        };
        return new Proxy(router, {
            get: (targetRouter, prop) => {
                if (targetRouter[prop] !== undefined) {
                    return targetRouter[prop];
                }
                if (prop === 'then') {
                    return targetRouter;
                }
                return (httpPathOrHandler, ...handlers) => {
                    let httpPath = undefined;
                    if (typeof httpPathOrHandler === 'string') {
                        httpPath = httpPathOrHandler;
                    }
                    else {
                        handlers = [httpPathOrHandler, ...handlers];
                    }
                    targetRouter.routes.push({
                        method: prop.toString(),
                        handlers,
                        path: httpPath
                    });
                };
            },
            set: (targetRouter, prop, value) => {
                if (targetRouter[prop] !== undefined) {
                    targetRouter[prop] = value;
                }
                return true;
            }
        });
    }
    Internals.buildRouterObject = buildRouterObject;
    Internals.ResolveOnResponseEventQueue = async (aReq, aRes, body, error) => {
        if (aReq._onResponseEvent.length === 0) {
            return;
        }
        aReq._onResponseEvent.forEach((r) => {
            Plata.FastPromise(() => r(aReq, aRes, body, error)).catch(() => undefined);
        });
    };
    function buildRequestHandler(r) {
        if (Array.isArray(r)) {
            return r.map(h => buildRequestHandler(h));
        }
        return async (req, res, next) => {
            const aReq = req;
            const aRes = res;
            if (aReq.user === undefined) {
                aReq.user = Object.create(null);
            }
            if (aReq.extras === undefined) {
                aReq.extras = Object.create(null);
            }
            if (aReq._onResponseEvent === undefined) {
                aReq._onResponseEvent = [];
            }
            if (aRes.addOnResponseEvent === undefined) {
                aRes.addOnResponseEvent = (callback) => {
                    aReq._onResponseEvent.push(callback);
                };
            }
            if (aRes.oldJson === undefined) {
                aRes.oldJson = aRes.json;
            }
            aRes.json = (body) => {
                Plata.FastPromise(async () => { Internals.ResolveOnResponseEventQueue(aReq, aRes, body, undefined); });
                return aRes.oldJson(body);
            };
            aRes.error = error => {
                Plata.FastPromise(async () => { Internals.ResolveOnResponseEventQueue(aReq, aRes, undefined, error); });
                return aRes.oldJson(error);
            };
            return r(aReq, aRes, next);
        };
    }
    Internals.buildRequestHandler = buildRequestHandler;
})(Internals || (exports.Internals = Internals = {}));
function processRoutes(routes) {
    const indexRoutes = [];
    const normalRoutes = [];
    for (let i = routes.length - 1; i >= 0; i--) {
        const route = routes[i];
        const r = {
            ...route,
            exports: route.exports.default,
            httpRoute: node_path_1.default.normalize(route.filePath
                .replace('__BUILD__', '')
                .replace(Plata.ProjectDir.replace(/\\/g, '/'), '')
                .replace('routes', '')
                .replace(/(\.ts|\.js)$/, '')
                .replace(/index/, '')
                .replace(/\{(.*?)\}/g, ':$1')
                .replace(/\[(.*?)\]/g, ':$1?')).replace(/\\/g, '/'),
        };
        if (r.name === 'index') {
            indexRoutes.push(r);
            continue;
        }
        normalRoutes.push(r);
    }
    normalRoutes.unshift(...indexRoutes.sort((x, y) => x.httpRoute.length - y.httpRoute.length));
    return normalRoutes;
}
async function loadRoutesFromProject() {
    const routes = await require('@@/routes/*.*');
    if (routes.errorID !== undefined) {
        return routes;
    }
    return processRoutes(routes);
}
async function buildExpressRouter(requiredRoutes) {
    const router = await (0, custom_1.getCustomExpress)();
    router.routes = [];
    router.swaggerHide = false;
    for (const r of requiredRoutes) {
        const v = await r.exports(Internals.buildRouterObject(r.httpRoute));
        const routes = v.routes;
        const swaggerHide = v.swaggerHide;
        for (let i = 0; i < routes.length; i++) {
            const route = routes[i];
            let httpPath = r.httpRoute;
            if (route.path !== undefined) {
                httpPath = node_path_1.default.normalize(`${httpPath}/${route.path}`).replace(/\\/g, '/');
            }
            router[route.method](httpPath, ...route.handlers.map(Internals.buildRequestHandler));
            router.routes.push({
                path: httpPath,
                method: route.method,
                handlers: [],
                swaggerHide: swaggerHide
            });
        }
    }
    return router;
}
//# sourceMappingURL=router.js.map