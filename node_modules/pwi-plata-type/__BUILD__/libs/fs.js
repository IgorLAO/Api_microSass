"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlataFs = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = __importDefault(require("node:fs"));
const node_readline_1 = __importDefault(require("node:readline"));
const glob_1 = __importDefault(require("glob"));
var PlataFs;
(function (PlataFs) {
    PlataFs.constants = promises_1.default.constants;
    PlataFs.fs = promises_1.default;
    function access(path, mode) {
        return PlataFs.fs.access(path, mode).then(() => true, () => false);
    }
    PlataFs.access = access;
    PlataFs.createWriteStream = node_fs_1.default.createWriteStream;
    PlataFs.createReadStream = node_fs_1.default.createReadStream;
    async function ReadEnvFileToPromise(p) {
        const envFile = Object.create(null);
        const result = await ReadFileAsync(p, async (line) => {
            if (line[0] === '#')
                return;
            if (line !== '') {
                const env = line.split('=');
                if (env.length >= 2) {
                    const [key, ...v] = env;
                    let value = v.join('=');
                    if (value[0] === '{' && value.slice(-1) === '}')
                        value = process.env[value.slice(1, -1)] ?? '';
                    if (value !== '')
                        envFile[key] = value;
                }
            }
        });
        if (result !== null) {
            return result;
        }
        return envFile;
    }
    PlataFs.ReadEnvFileToPromise = ReadEnvFileToPromise;
    PlataFs.cp = (source, destination, opts) => {
        return promises_1.default.cp(source, destination, opts).then(() => null, err => {
            return {
                errorID: 'PLFS001',
                msg: err.message,
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            };
        });
    };
    function ReadFileSync(file, callback) {
        return new Promise(resolve => {
            try {
                const content = [];
                const stream = node_readline_1.default.createInterface({
                    input: PlataFs.createReadStream(file),
                    crlfDelay: Infinity
                });
                stream.on('close', () => {
                    resolve(content.join('\n'));
                });
                stream.on('line', (line) => {
                    content.push(callback(line));
                });
            }
            catch (err) {
                resolve({
                    errorID: 'PLTRF0004',
                    msg: `Error while reading file: ${file}`,
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                });
            }
        });
    }
    PlataFs.ReadFileSync = ReadFileSync;
    function ReadFileAsync(file, callback) {
        return new Promise(resolve => {
            try {
                const promises = [];
                const stream = node_readline_1.default.createInterface({
                    input: PlataFs.createReadStream(file),
                    crlfDelay: Infinity
                });
                stream.on('close', () => {
                    Promise.all(promises).then(() => resolve(null), err => resolve({
                        errorID: 'PPFRFA0002',
                        msg: `Unexpected error while reading file: ${file}`,
                        error: {
                            message: err?.toString(),
                            stack: err?.stack ?? new Error().stack
                        }
                    }));
                });
                stream.on('line', line => {
                    promises.push(Plata.FastPromise(() => callback(line)));
                });
            }
            catch (err) {
                return resolve({
                    errorID: 'PPFRFA0001',
                    msg: `Unexpected error while reading file: ${file}`,
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                });
            }
        });
    }
    PlataFs.ReadFileAsync = ReadFileAsync;
    async function FindFiles(folders, file) {
        const files = [];
        for (const folder of folders) {
            files.push(...glob_1.default.sync(`${folder.replace(/\\/g, '/')}/**/${file}`));
        }
        return files;
    }
    PlataFs.FindFiles = FindFiles;
    class CliTools {
        sourcePath;
        destPath;
        constructor(sourcePath, destPath) {
            this.destPath = destPath;
            this.sourcePath = sourcePath;
        }
        async mkdirIfNotExists(dir) {
            try {
                const p = node_path_1.default.resolve(dir.toString());
                if (!(await access(p))) {
                    await promises_1.default.mkdir(p, { recursive: true });
                }
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        async createFolderToDest(folder) {
            const destinationPath = node_path_1.default.join(this.destPath.toString(), folder);
            await this.mkdirIfNotExists(destinationPath);
        }
        async forEachFileInFolder(folder, callback) {
            try {
                const folderPath = node_path_1.default.resolve(folder.toString());
                const files = await promises_1.default.readdir(folder);
                const promises = [];
                files.forEach(file => {
                    const filePath = node_path_1.default.join(folderPath, file);
                    promises.push(Promise.resolve().then(() => callback(file, filePath)));
                });
                await Promise.all(promises);
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        async copyFile(sourcePath, destinationPath) {
            try {
                const s = node_path_1.default.resolve(sourcePath.toString());
                const d = node_path_1.default.resolve(destinationPath.toString());
                if (!(await access(d))) {
                    await promises_1.default.copyFile(s, d);
                }
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        async copyFileIfNotExists(sourcePath, destinationPath) {
            try {
                const s = node_path_1.default.resolve(sourcePath.toString());
                const d = node_path_1.default.resolve(destinationPath.toString());
                if (!(await access(d))) {
                    await this.copyFile(s, d);
                }
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        async copyFolderToDest(folder) {
            const sourcePath = node_path_1.default.join(this.sourcePath.toString(), folder);
            const destinationPath = node_path_1.default.join(this.destPath.toString(), folder);
            await this.mkdirIfNotExists(destinationPath);
            await this.forEachFileInFolder(sourcePath, (file, filePath) => this.copyFileIfNotExists(filePath, node_path_1.default.join(destinationPath, file)));
        }
        async syncFolder(folder) {
            const sourcePath = node_path_1.default.join(this.sourcePath.toString(), folder);
            const destinationPath = node_path_1.default.join(this.destPath.toString(), folder);
            await this.mkdirIfNotExists(destinationPath);
            await this.forEachFileInFolder(sourcePath, (file, filePath) => this.copyFile(filePath, node_path_1.default.join(destinationPath, file)));
        }
        async copyFileToDest(file) {
            const sourcePath = node_path_1.default.join(this.sourcePath.toString(), file);
            const destinationPath = node_path_1.default.join(this.destPath.toString(), file);
            await this.copyFileIfNotExists(sourcePath, destinationPath);
        }
        async syncFileToDest(file) {
            const sourcePath = node_path_1.default.join(this.sourcePath.toString(), file);
            const destinationPath = node_path_1.default.join(this.destPath.toString(), file);
            await this.copyFile(sourcePath, destinationPath);
        }
        async createFileToDest(file, content) {
            const destinationPath = node_path_1.default.join(this.destPath.toString(), file);
            await promises_1.default.writeFile(destinationPath, content);
        }
    }
    PlataFs.CliTools = CliTools;
})(PlataFs || (exports.PlataFs = PlataFs = {}));
//# sourceMappingURL=fs.js.map