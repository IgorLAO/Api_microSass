#!/usr/bin/env node

import path from 'node:path'
import { ok } from 'node:assert'
import cluster from 'node:cluster'
import { loadRuntimeLibs } from './runtime/_setupRuntime'
import { PlataFs } from '../libs/fs'
import { PlataEnvLoader } from '../libs/env'
import { PlataBuild } from '../libs/build'
import { PlataBuildWasm } from '../libs/build_wasm'

async function compile() {
    if (!cluster.isPrimary) return

    await PlataBuild.compile({
        basePath: Plata.ProjectDir,
        mapFiles: true,
        packageJsonSetup: false,
        otimizar: false,
    })
    // build({
    //     basePath: Plata.ProjectDir,
    //     configFilePath: 'tsconfig.json',
    //     compilerOptions: {
    //         newLine: 'LF',
    //         rootDir: '.'
    //     },
    //     include: [
    //         './**/*'
    //     ],
    //     exclude: [
    //         './__BUILD__',
    //         './__RELEASE__',
    //         './node_modules',
    //         './.vscode',
    //         './.git',
    //         '.gitignore'
    //     ],
    //     copyOtherToOutDir: true,
    //     clean: {
    //         outDir: true,
    //         declarationDir: true,
    //         outFile: true
    //     },
    // })
}

const shouldCompile = async () => { // TODO Colocar a compilição e essa função em um arquivo separado
    if (process.argv.findIndex(p => p === '--skip-recompile') !== -1 || Plata.ProjectJson['plata_skip_recompile'] !== undefined)
        return Plata.files.access(path.join(Plata.ProjectDir, '__BUILD__')).then(r => !r)
    ;

    return true
}

const main = async () => {
    const g = global as any

    g.Plata = await loadRuntimeLibs()

    g.Plata.files = PlataFs

    if (await shouldCompile())
        await compile()
    ;

    module.constructor.prototype.require = function (pathRequire) {
        const self = this;
        ok(typeof pathRequire === 'string', 'path must be a string');
        ok(pathRequire, 'missing path');
    
        try {
            switch (pathRequire.slice(0,2)) {
                case '@@':
                    pathRequire = pathRequire.replace('@@', `${Plata.ProjectDir}/__BUILD__`)
                break
                case '++':
                    pathRequire = pathRequire.replace('++', `${Plata.PlataDir}/__BUILD__`)
                break
            }
    
            pathRequire = pathRequire.replace(/\\/g, '/')

            switch (path.extname(pathRequire)) {
                case '.env':
                    return Plata.FastPromise(() => Plata.ReadEnvFileToPromise(pathRequire))
                break
                case '.*':
                    return Plata.FastPromise(() => Plata.RequireFolder(path.dirname(pathRequire)))
                break
                default:
                    return self.constructor._load(pathRequire, self)
                break
            }

            
        } catch (err) {
            // if module not found, we have nothing to do, simply throw it back.
            if (err.code === 'MODULE_NOT_FOUND') {
                throw err;
            }
            // resolve the path to get absolute path
            pathRequire = path.resolve(__dirname, pathRequire)
    
            // Write to log or whatever
            console.log('Error in file: ' + pathRequire);
        }
    }

    // inicializa a config da plata
    g.Plata.config = process.env

    const envFile = await PlataEnvLoader.load()

    if (envFile.errorID !== undefined) {
        console.log(envFile)
        process.exit(1)
    }

    for (const key in envFile) {
        g.Plata.config[key] = envFile[key]
    }

    await PlataBuildWasm.loadFilesWasm()

    // roda o sript solicitado
    const run = process.argv[process.argv.indexOf('+') + 1]

    const app: { main: () => Promise<void> } = require(`++/bin/${run}`)

    await app.main()

}

main()