import { Effect } from 'effect'

declare global {
    interface PlataRuntime extends PlataRuntimeEType {}
}

type PlataRuntimeEType = typeof PlataRuntimeE


export namespace PlataRuntimeE {
    export async function PromiseAll<
        T extends readonly unknown[] | [],
        R = RemovePlataResultOnPromiseAll<{ -readonly [P in keyof T]: Awaited<T[P]> }>
    >(promises: T): PlataPromise<
        R extends [] ? 
            T extends Promise<infer U>[] ? RemovePlataResult<U>[]
            : never
        : R
    > {
        if (promises.length === 0) {
            return [] as any
        }

        const results: any[] = []
        let error: PlataError | null = null
        const promisesWithID = promises.map((p, i) => ({
            promise: p,
            id: i 
        }))

        const effect = Effect.forEach(promisesWithID, (p) => Effect.gen(function* (_) {
            const result: PlataResult<any> = yield* _(Effect.promise(() => p.promise))
            
            if (result.errorID !== undefined) {
                error = result
                return yield* _(Effect.interrupt)
            }
    
            results[p.id] = result
        }), { concurrency: 'unbounded' })

        await Effect.runPromise(effect).catch((err) => {
            if (error === null)
                error = {
                    errorID: 'PBRUNEFFPROALL001',
                    msg: 'Erro ao realizar a operação',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                }
            ;
        })

        if (error !== null) {
            return error
        }
    
        return results as any
    }
}