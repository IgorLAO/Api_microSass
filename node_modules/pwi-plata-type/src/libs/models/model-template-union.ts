export class ModelTemplateUnion<const C extends Model.TemplateUnionConfig, const R extends Model.TemplateRecord> {
    public readonly config: C
    public readonly templates: R
    public readonly type: Model.ExtractModelUnionType<C, R>
    public readonly filters: Set<(x: Model.ExtractModelUnionTypeFilter<C, R>) => Model.ExtractModelUnionTypeFilter<C, R>>

    constructor(config: C, templates: R) {
        this.config = config
        this.templates = templates
        this.filters = new Set()
    }

    public addFilter(filter: (x: Model.ExtractModelUnionTypeFilter<C, R>) => Model.ExtractModelUnionTypeFilter<C, R>) {
        this.filters.add(filter)
    }

    public getExtractFromUnion(value: any): PlataResult<Model.ExtractModelUnionReturn<C, R>> {
        let type = `${value[this.config.key] ?? null}`
        value[this.config.key] = value[this.config.key] ?? null

        const template = this.templates[type]

        if (template === undefined) {
            return {
                errorID: 'PLMODUNEXTFRUN001',
                msg: `O Valor de ${this.config.key} tem que ser ${Object.keys(this.templates).join(',')}`,
                error: type
            }
        }

        return {
            model: template,
            value: value,
        } as any
    }

    /**
     * Essa função so é para ser usada dentro da plataforma, considera que logo depois será rodado o validate
     */
    public filter(value: any): any {
        const extraced = this.getExtractFromUnion(value)

        if (extraced.errorID !== undefined) {
            return value
        }

        if (extraced.model.filter !== undefined) {
            value = extraced.model.filter(value)
        }

        this.filters.forEach(f => { value = f(value)})

        return value
    }

    public async validate(value: any, skipFilter?: true): Promise<Model.ModelValidateReturnHelper<typeof this.type, undefined>> {
        const extraced = this.getExtractFromUnion(value)

        if (extraced.errorID !== undefined) {
            return {
                errors: [extraced],
                value: undefined
            }
        }

        if (!skipFilter) {
            this.filters.forEach(f => { value = f(value) })
        }

        const result = await extraced.model.validate(extraced.value, skipFilter)

        if (result.errors !== undefined) {
            return {
                errors: result.errors,
                value: undefined
            }
        }

        return {
            errors: undefined,
            value: result.value
        }
    }
}