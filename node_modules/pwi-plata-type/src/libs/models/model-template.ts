import { ModelsInternals } from "./tools"

export class ModelTemplate<T extends Model.Template, C extends Model.Converters<T>> {
    public readonly template: T
    public readonly converters: C | {}
    public readonly validations: Map<string, Model.ModelTemplateValidation<T>>
    public readonly filters: Map<string, Model.ModelTemplateFilter<T>>
    public readonly type: Model.ExtractTemplateType<T>

    constructor(template: T, converters: C | {}) {
        this.template = template
        this.converters = converters
        this.validations = new Map()
        this.filters = new Map()
    }

    public addValidation(nome: string, callback: Model.ModelTemplateValidation<T>) {
        this.validations.set(nome, callback)
    }

    public addFilter(nome: string, callback: Model.ModelTemplateFilter<T>) {
        this.filters.set(nome, callback)
    }

    public convert: Model.ModelConvertFuntion<T, C> = (value, to) => {
        const c: Model.ConvertFunction<T, any> | undefined = this.converters[to as string]

        if (c === undefined)
            return {
                errorID: 'BPLM0002',
                msg: 'Invalid Converter',
                error: to
            }
        ;

        try {
            return c(value)
        } catch (e) {
            return {
                errorID: 'BPLM0003',
                msg: 'Unexpected converter error',
                error: e
            }
        }
    }

    public filter(value: any) {
        if (!value) {
            value = {}
        }

        let v = ModelsInternals.filterTemplate(value, this.template)

        this.filters.forEach(f => {
            v = f(v)
        })

        return v
    }

    public async validate(value: any, skipFilter?: true): Promise<Model.ModelValidateReturn<T>> {
        const v = skipFilter ? value : this.filter(value)
        const errors = await ModelsInternals.validateTemplate(v, this.template)

        if (errors.errorID !== undefined) {
            return {
                value: v as any,
                errors: [errors]
            }
        }

        if (errors.length !== 0) {
            return {
                value: v as any,
                errors
            }
        }

        const promises: Promise<Model.ValidateReturn>[] = []

        this.validations.forEach(validation => {
            promises.push(validation(v as any))
        })

        const result: PlataResult<PlataError[]> = await Plata.FastPromise(() => Promise.all(promises)).then(
            r => ([] as Model.ValidateReturn[]).concat(...r).filter(v => v !== null),
            err => {
                return {
                    errorID: 'BPLM0002',
                    msg: `unexpected error while validating model`,
                    error: err
                }
            }
        ) as any

        if (result.errorID !== undefined) {
            return {
                value: v as any,
                errors: [result]
            }
        }

        return {
            value: v as any,
            errors: result.length !== 0 ? result : undefined
        }
    }
}