export function Min(min: number): Model.PrimitiveValidationType<any> {
    return async (nome: string, valor: any) => {
        if (valor < min) return {
            error: {
                errorID: "BPMVMIN001",
                msg: `O valor de ${nome} tem que ser maior que ${min}` 
            },
            continua: false,
        }

        return { continua: true }
    }
}

export function Max(max: number): Model.PrimitiveValidationType<any> {
    return async (nome: string, valor: any) => {
        if (valor > max) return {
            error: {
                errorID: "BPMVMIN001",
                msg: `O valor de ${nome} tem que ser maior que ${max}` 
            },
            continua: false,
        }

        return { continua: true }
    }
}

export function Enum<const T>(valores: T[]): Model.PrimitiveValidationType<T> {
    return async (nome: string, valor: any) => {
        if (valores.findIndex(v => `${valor}` === `${v}`) === -1) return {
            error: {
                errorID: 'BPMVEN0001',
                msg: `O campo ${nome} so pode ter os valores: ${valores.join(', ')}`,
                error: `${valor}`
            },
            continua: false,
        }

        return { continua: true }
    }
}

export function StringDateTime(): Model.PrimitiveValidationType<string> {
    return async (nome: string, valor: any) => {
        const regex = /(\d{4})-([01]\d)-([0-3]\d)T([0-2]\d):([0-5]\d):([0-5]\d)/

        if (!regex.test(valor)) {
            return {
                error: {
                    errorID: "BPVSDT001",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-ddTHH:MM:SS`,
                },
                continua: false
            }
        }

        const [ _, ano, mes, dia, hora, minutos, segundos ] = valor.match(regex)

        if (isNaN(+ano) || isNaN(+mes) || isNaN(+dia) || isNaN(+hora) || isNaN(+minutos) || isNaN(+segundos) ){
            return {
                error: {
                    errorID: "BPVSDT002",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-ddTHH:MM:SS` 
                },
                continua: false
            }
        }

        if ((+dia) > 31 || (+mes) > 12 || (+hora) > 24){
            return {
                error: {
                    errorID: "BCVSDT003",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-ddTHH:MM:SS`,
                },
                continua: false
            }
        }

        return { continua: true }
    }
}

export function DateTime(): Model.PrimitiveValidationType<Date> {
    return async (nome, value) => value instanceof Date ? { continua: true } : {
        error: {
            errorID: 'BPVDT001',
            msg: `O campo ${nome} não é do tipo Date`
        }, 
        continua: false
    }
} 

export function Decimal(tamanhoInteiro: number, casasDecimais: number, min?: number, max?: number): Model.PrimitiveValidationType<number> {
    return async (nome: string, valor: any) => {
        if (isNaN(+valor)) {
            return {
                error: {
                    errorID: "BPMVDEC001",
                    msg: `O campo ${nome} tem que ser um decimal` 
                },
                continua: false,
            }
        }

        const v = `${valor}`

        if (v.length > (tamanhoInteiro + casasDecimais + 1)) {
            return {
                error: {
                    errorID: "BPMVDEC002",
                    msg: `O campo ${nome} não pode ser maior que ${(tamanhoInteiro + casasDecimais + 1)}` 
                },
                continua: false,
            }
        }

        const n = v.split('.')

        if (n[0].length > tamanhoInteiro) {
            return {
                error: {
                    errorID: "BPMVDEC003",
                    msg: `A parte inteira do ${nome} não pode ter mais de ${tamanhoInteiro} digitos` 
                },
                continua: false,
            }
        }

        if (n[1] !== undefined) {
            if (n[1].length > casasDecimais) {
                return {
                    error: {
                        errorID: "BPMVDEC004",
                        msg: `A parte decimal do ${nome} não pode ter mais de ${casasDecimais} digitos` 
                    },
                    continua: false,
                }
            }
        }

        if (min !== undefined) {
            const result = await Min(min)(nome, valor)

            if (result.continua !== true)
                return result
            ;
        }

        if (max !== undefined) {
            const result = await Max(max)(nome, valor)

            if (result.continua !== true)
                return result
            ;
        }

        return { continua: true }
    }
}

export function Int(min?: number, max?: number): Model.PrimitiveValidationType<number> {
    return async (nome: string, valor: any) => {
        if (isNaN(+valor)) {
            return {
                error: {
                    errorID: "BPMVINT001",
                    msg: `O campo ${nome} tem que ser um número inteiro` 
                },
                continua: false,
            }
        }

        const v = +valor

        if (Math.round(v) !== v) {
            return {
                error: {
                    errorID: "BPMVINT002",
                    msg: `O campo ${nome} tem que ser um número inteiro` 
                },
                continua: false,
            }
        }

        if (min !== undefined) {
            const result = await Min(min)(nome, valor)

            if (result.continua !== true)
                return result
            ;
        }

        if (max !== undefined) {
            const result = await Max(max)(nome, valor)

            if (result.continua !== true)
                return result
            ;
        }

        return { continua: true }
    }
}

export function Optional(): Model.PrimitiveValidationType<any, null> {
    return async (_nome: string, valor: any) => {
        if (!valor) {
            return { continua: false }
        }

        return { continua: true }
    }
}

export function Required(): Model.PrimitiveValidationType {
    return async (nome: string, valor: any) => {
        if (valor === null) {
            return {
                error: { 
                    errorID: "BPCVREQ001",
                    msg: `O campo ${nome} é obrigatório` 
                },
                continua: false
            }
        }
    
        return { continua: true }
    }
}

export function SmallDateTime(): Model.PrimitiveValidationType<string> {
    return async (nome: string, valor: any) => {
        const regex = /(\d{4})-([01]\d)-([0-3]\d)/

        if (!regex.test(valor)) {
            return {
                error: { 
                    errorID: "BPCVDT001",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-dd` 
                },
                continua: false
            }
        }
    
        const [ _, ano, mes, dia ] = valor.match(regex)
    
        if (isNaN(+ano) || isNaN(+mes) || isNaN(+dia)){
            return {
                error: { 
                    errorID: "BPCVDT002",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-dd` 
                },
                continua: false
            }
        }
    
        if ((+dia) > 31 || (+mes) > 12 ){
            return {
                error: {
                    errorID: "BPCVDT003",
                    msg: `A data no campo ${nome} tem que está no formato yyyy-mm-dd` 
                },
                continua: false
            }
        }
    
        //https://sqltutorialtips.blogspot.com/2016/11/smalldatetime-vs-datetime.html
        if (new Date(+ano, mes - 1, +dia) >= new Date(2079, 11, 31)) {
            return {
                error: {
                    errorID: "BPCVDT004",
                    msg: `A data no campo ${nome} não pode ser maior que 2079-12-31` 
                },
                continua: false
            }
        }
    
        return { continua: true }
    }
}

export function Telefone(): Model.PrimitiveValidationType<string> {
    return async (nome: string, valor: any) => {
        const v = `${valor}`.split('-')

        if (v.length !== 2) {
            return {
                error: { 
                    errorID: "BPVTEL001",
                    msg: `O campo ${nome} tem que ser um telefone em no formato 99-999999999` 
                },
                continua: false
            }
        }

        if (v[0].length !== 2 || (v[1].length !== 8 && v[1].length !== 9)) {
            return {
                error: {
                    errorID: "BPVTEL002",
                    msg: `O campo ${nome} tem que ser um telefone em no formato 99-999999999` 
                },
                continua: false
            }
        }

        if (!+v[0] || !+v[1]) {
            return {
                error: {
                    errorID: "BPVTEL003",
                    msg: `O campo ${nome} tem que ser um telefone em no formato 99-999999999` 
                },
                continua: false
            }
        }

        return { continua: true }
    }
}

export function TelefoneDDI(): Model.PrimitiveValidationType<string> {
    return async (nome: string, valor: any) => {
        const [ ddi, t ] = `${valor}`.split(' ')
        const telefone = `${t}`.split('-')

        if (telefone.length !== 2) {
            return {
                error: { 
                    errorID: "BPVTELD001",
                    msg: `O campo ${nome} tem que ser um telefone em no formato +000 99-999999999` 
                },
                continua: false
            }
        }

        if (telefone[0].length !== 2 || (telefone[1].length !== 8 && telefone[1].length !== 9)) {
            return {
                error: {
                    errorID: "BPVTELD002",
                    msg: `O campo ${nome} tem que ser um telefone em no formato +000 99-999999999` 
                },
                continua: false
            }
        }

        if (!+telefone[0] || !+telefone[1]) {
            return {
                error: {
                    errorID: "BPVTELD003",
                    msg: `O campo ${nome} tem que ser um telefone em no formato +000 99-999999999` 
                },
                continua: false
            }
        }

        if (ddi.length !== 4) {
            return {
                error: {
                    errorID: "BPVTELD004",
                    msg: `O campo ${nome} tem que ser um telefone em no formato +000 99-999999999` 
                },
                continua: false
            }
        }

        if (ddi[0] !== '+' || !+ddi) {
            return {
                error: {
                    errorID: "BPVTELD005",
                    msg: `O campo ${nome} tem que ser um telefone em no formato +000 99-999999999` 
                },
                continua: false
            }
        }

        return { continua: true }
    }
}

export function VarChar(max: number, min?: number): Model.PrimitiveValidationType<string> {
    return async (nome: string, valor: any) => {
        if (`${valor}`.length > max) {
            return {
                error: {
                    errorID: "BPVVARC001",
                    msg: `O campo ${nome} tem que ter menos de ${max} caracteres` 
                },
                continua: false
            }
        }

        if (min !== undefined) {
            if (`${valor}`.length < min) {
                return {
                    error: {
                        errorID: "BPVVARC002",
                        msg: `O campo ${nome} tem que ter no mínimo ${min} caracteres` 
                    },
                    continua: false
                }
            }
        }

        return { continua: true }
    }
}

export function Boolean(): Model.PrimitiveValidationType<boolean> {
	return async (nome: string, valor: any) => {
		if (typeof valor !== 'boolean') {
			return { continua: false, error: {errorID: 'BPVBOL001', msg: `O campo ${nome} precisa ser um boolean`} }
		}
		
		return { continua: true }
	}
}

export function useModel<const T extends Model.ModelClass>(model: T): Model.PrimitiveValidationType<T['type']> {
    const f: Model.PrimitiveValidationType<T['type']> = async (nome: string, valor: any) => {
        if (typeof valor !== 'object') {
            return {
                continua: false,
                error: {
                    errorID: 'PLMVALUSML002',
                    msg: `O valor de ${nome} precisa ser um objeto`,
                    error: valor
                }
            }
        }

        const result = await model.validate(valor, true)

        if (result.errors !== undefined) {
            return {
                continua: false,
                error: {
                    errorID: 'PLMVALUSML001',
                    msg: `Exitem problemas dentro do objeto ${nome}`,
                    error: result.errors
                }
            }
        }

        return {
            continua: true
        }
    }

    if (model.filter !== undefined) {
        f.filter = model.filter.bind(model)
    }

    return f
}