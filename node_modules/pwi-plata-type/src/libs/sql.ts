import knex, { Knex } from "knex"
import { ModelTemplate } from "./models"
import schemaInspector from 'knex-schema-inspector';
import { randomUUID } from "node:crypto"

export namespace Internals {
    export function context<T extends {} | undefined>(c: T): T extends undefined ? void : T {
        const context = this.queryContext() ?? Object.create(null)

        if (context._userContext === undefined) {
            context._userContext = Object.create(null)
        }

        if (c === undefined) {
            return context._userContext
        }

        context._userContext = c

        return this.queryContext(context)
    }

    export function includeOne(table: string, type: Sql.Joins,s: Knex.JoinCallback) {
        const t: Knex.QueryBuilder = this
        const context = t.queryContext() ?? Object.create(null)

        if (context._joins === undefined) {
            context._joins = []
        }

        context._joins.push(table)

        const q = t.queryContext(context)

        switch(type) {
            case 'CROSS JOIN':
                return q.crossJoin(table, s)
            break
            case 'FULL OUTER JOIN':
                return q.fullOuterJoin(table, s)
            break
            case 'INNER JOIN':
                return q.innerJoin(table, s)
            break
            case 'JOIN':
                return q.join(table, s)
            break
            case 'LEFT JOIN':
                return q.leftJoin(table, s)
            break
            case 'LEFT OUTER JOIN':
                return q.leftOuterJoin(table, s)
            break
            case 'OUTER JOIN':
                return q.outerJoin(table, s)
            break
            case 'RIGHT JOIN':
                return q.rightJoin(table, s)
            break
        }
    }

    export function getConnTable(this: Knex.QueryBuilder, table: string, trxName?: string) {
        let conn = this.table(table)

        if (trxName !== undefined && conn.comment !== undefined) {
            conn = conn.comment(`TRX: ${trxName}`) 
        }

        return conn
    }
}

export class Driver<InTransaction extends boolean> {
    public readonly config: Knex.Config
    public readonly inTransaction: InTransaction
    public readonly conn: InTransaction extends true ? Knex.Transaction : Knex
    public readonly trxConn: InTransaction extends true ? Knex.Transaction : Knex
    public readonly cacheTable: Map<string, Sql.CacheTable>
    public readonly logQuerys: boolean
    public readonly trxName: string | undefined

    constructor(config: Knex.Config, inTransaction: InTransaction, trx?: Knex.Transaction, cacheTable?: Map<string, Sql.CacheTable>) {
        this.inTransaction = inTransaction
        this.config = config

        this.logQuerys = Plata.config.ENV === 'debug' || Plata.config._PLATA_SQL_SHOWQUERY === '1' 


        if (!this.inTransaction) {
            if (config.pool === undefined)
                config.pool = {
                    min: 1,
                    max: 1
                }
            ;
            
            if (!Plata._knexExtended) {
                knex.QueryBuilder.extend('context', Internals.context)
                knex.QueryBuilder.extend('includeOne', Internals.includeOne)
                knex.QueryBuilder.extend('getConnTable', Internals.getConnTable)

                Plata._knexExtended = true
            }

            const trxPool = {
                min: 1,
                max: 1
            }
            
            if (Plata.config.__PLATA_SQL_TRX_MIN_POOL) {
                trxPool.min = +Plata.config.__PLATA_SQL_TRX_MIN_POOL
            }
            
            if (Plata.config.__PLATA_SQL_TRX_MAX_POOL) {
                trxPool.max = +Plata.config.__PLATA_SQL_TRX_MAX_POOL
            }

            this.conn = knex(config) as any
            this.trxConn = knex({
                ...config,
                pool: trxPool
            }) as any
        } else {
            this.conn = trx as any
            this.trxConn = trx as any
        }

        this.trxName = this.conn?.userParams?.trxName
        if (this.logQuerys) {
            this.conn.on('query', (...args) => console.log(...args))
            this.conn.on('query-error', (...args) => console.error(...args))
        }
        this.cacheTable = cacheTable ?? new Map()
    }

    public async onOpenTrx(trx: Driver<true>): PlataPromise<Driver<true>> {
        return trx
    } 

    public runRawWithComment(query: { sql: string, bindings: readonly any[] }) {
        if (this.trxName === undefined) {
            return this.conn.raw(query.sql, query.bindings)
        }

        return this.conn.raw(`/*TRX: ${this.trxName}*/${query.sql}`, query.bindings)
    }

    public select<T extends Model.Template, C extends Model.Converters<T>>(table: string, model: ModelTemplate<T, C>) {
        return {
            build: (builder: Sql.Builder<T>) => 
                new Query(
                    builder(this.conn.queryBuilder().getConnTable(table, this.trxName)), 
                    model,
                    table,
                )
            ,
        }
    }

    public async rawMappedSelect<const I extends Sql.SqlRawSelectInfo<T>, T>(queryInfo: I): PlataPromise<Sql.ExtractSqlRawSelectInfo<I>[]> {
        let queryBuilder = this.conn.queryBuilder().from(queryInfo.table)
        const validades = new Set<string>()

        for (const col in queryInfo.cols) {
            queryBuilder = queryInfo.cols[col][0](queryBuilder as any) as any
            
            if (queryInfo.cols[col][2] === 'required') {
                validades.add(col)
            }
        }

        const sql = queryInfo.query(queryBuilder as any, {} as any).toSQL()

        const result: PlataResult<any[]> = await this.runRawWithComment(sql).then(
            r => r,
            err => ({
                errorID: 'PLSQLRWSEL001',
                msg: 'Unexpected error while select',
                error:{
                    message: err?.toString(),
                    stack: new Error().stack
                },
            })
        )

        if (result.errorID !== undefined) {
            return result
        }

        if (validades.size !== 0) {
            for (let i = 0; i < result.length; i++) {
                const row = result[i]
                
                for (const col of validades) {
                    if (row[col] === null || row[col] === undefined) {
                        return {
                            errorID: 'PLSQLRWSEL002',
                            msg: 'Not valid select',
                            error:{
                                message: `${col} is NULL`,
                                stack: new Error().stack
                            },
                        }
                    }
                }
            }
        }

        return result
    }

    public async insert<T extends Model.Template, C extends Model.Converters<T>>(table: string, model: ModelTemplate<T, C>, values: Model.ParcialTemplateType<T>[], options?: Sql.InsertOptions): PlataPromise<Model.ExtractTemplateType<T>[]> {
        if (this.config.client === 'mssql') {
            const sql = this.conn.queryBuilder().getConnTable(table, this.trxName).insert(
                values,
                '*',
                {
                    includeTriggerModifications: options?.ignoreTrigger === undefined
                }
            ).toSQL()

            return this.runRawWithComment(sql).then(
                r => r,
                err => Plata.BuildPlataError({
                    errorID: 'PLSQL001',
                    msg: 'Unexpected error while inserting',
                    error:{
                        message: err?.toString(),
                        stack: new Error().stack
                    },
                })
            )
        }

        // TODO ver a necessidade de comentario de trx nas outras conexões

        if (options?.ignoreTrigger === true)
            return this.conn.queryBuilder().getConnTable(table, this.trxName).insert(
                values,
                '*',
                {
                    includeTriggerModifications: options?.ignoreTrigger
                }
            ).then(
                r => r,
                err => Plata.BuildPlataError({
                    errorID: 'PLSQLINS001',
                    msg: 'Unexpected error while inserting',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    },
                })
            )
        ;

        const key: PlataResult<string> = await schemaInspector(this.conn).primary(table).then(
            r => {
                if (r === null) {
                    return Plata.BuildPlataError({
                        errorID: 'PLSQL007',
                        msg: 'Tabela não tem chave primária'
                    })
                }

                return r
            },
            err => Plata.BuildPlataError({
                errorID: 'PLSQL006',
                msg: 'Erro ao consultar a chave primária da tabela',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            })
        )

        if (key.errorID !== undefined) {
            return key
        }

        return this.transaction(
            async (trx) => {
                const result: number[] = await trx.conn.queryBuilder().getConnTable(table, `${trx.trxName}<->${this.trxName}`).insert(
                    values,
                )

                return trx.conn.select('*').from(table).whereIn(key, result)
            }
        )
    }

    public update<T extends Model.Template, C extends Model.Converters<T>>(table: string, model: ModelTemplate<T, C>) {
        return {
            build: async (s: Sql.Builder<T>, set: Model.ParcialTemplateType<T>): PlataPromise<true> => {
                const sql = s(this.conn.queryBuilder().getConnTable(table, this.trxName)).update(set as any).toSQL()

                return this.runRawWithComment(sql).then(
                    () => true,
                    err => Plata.BuildPlataError({
                        errorID: 'PLSQL002',
                        msg: 'Unexpected error while update',
                        error: {
                            message: err?.toString(),
                            stack: err?.stack ?? new Error().stack
                        }
                    })
                )
            },
        }
    }

    public log(text: string, ...extras: any[]) {
        if (this.logQuerys === true) {
            console.log(text, ...extras)
        }
    }

    /** @deprecated */
    public trasation<T = any>(transaction: Sql.TransactionFunction<Driver<true>, T>, config?: Knex.TransactionConfig) {
        return this.conn.transaction(async trx => {
            const transactionDriver = new Driver(this.config, true, trx, this.cacheTable)

            const result = await transaction(transactionDriver)

            return result
        }, config).then(
            r => r,
            err => {
                if (!err) {
                    err = Object.create(null)
                }

                err.originalError = undefined

                return Plata.BuildPlataError({
                    errorID: 'PLSQL003',
                    msg: 'Unexpected error in transation',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    },
                })
            }
        )
    }

    public async getTransactionDriver(config?: Knex.TransactionConfig): PlataPromise<Driver<true>> {
        const trxName = randomUUID()
        const provider = await this.trxConn.transactionProvider({
            ...config,
            doNotRejectOnRollback: true,
        })

        this.log(`[PLATA-SQL] [TRX-${trxName}] - Inciando provider`)

        // Inicia a transação
        const trx: PlataResult<Knex.Transaction> = await provider().catch(
            e => ({
                errorID: 'PLSQLGETTRX001',
                msg: 'Erro ao iniciar a transação',
                error: {
                    message: e?.toString(),
                    stack: e?.stack ?? new Error().stack,
                    trxName
                }
            })
        )

        if (trx.errorID !== undefined) {
            this.log(`[PLATA-SQL] [TRX-${trxName}] - Conexão  não foi aberta - ${JSON.stringify(trx)}`)
            return trx
        }

        trx.userParams.trxName = trxName

        this.log(`[PLATA-SQL] [TRX-${trxName}] - Conexão foi aberta`)
        return this.onOpenTrx(new Driver(this.config, true, trx, this.cacheTable))
    }

    public async transaction<T extends Sql.TransactionReturn>(transaction: Sql.TransactionResultFunction<Driver<true>, T>, config?: Knex.TransactionConfig): PlataPromise<T> {
        const driver = await this.getTransactionDriver(config)

        if (driver.errorID !== undefined) {
            return driver
        }

        const transPromise = Plata.FastPromise(() => driver.conn.executionPromise.catch((...args) => console.log(...args)))
        
        try {
            const resultTransation = await transaction(driver)

            if (resultTransation.errorID !== undefined) {
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback -> Erro da API na transação - ${JSON.stringify(resultTransation)}`)
                await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err))
                await transPromise
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback realizado`)

                return resultTransation
            }

            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Commit -> Realizando Commit`)
            const resultCommit: PlataResult<true> = await driver.conn.commit().then(
                () => true,
                err => ({
                    errorID: 'PLSQLTRX003',
                    msg: 'Erro inesperado ao realizar o commit',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                })
            )

            
            if (resultCommit.errorID !== undefined) {
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Erro no commit, realizando Rollback`)
                await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err))
                await transPromise
                this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Roollback realizado`)
                return resultCommit
            }

            await transPromise

            return resultTransation
        } catch (err) {
            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Erro inesperado: `, err)
            await driver.conn.rollback().catch((...err) => console.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}]`, ...err))
            await transPromise
            this.log(`[PLATA-SQL] [TRX-${driver.conn.userParams?.trxName}] - Rollback -> Roollback realizado`)

            return {
                errorID: 'PLSQLTRX002',
                msg: 'Erro inesperado ao realizar a transação ',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            }
        }
    }

    public async getColumns(table: string): PlataPromise<Record<string | number | symbol, Knex.ColumnInfo>> {
        if (Plata.config._PLATA_SQL_CACHETABLE !== '1')
            return this.getColumsBanco(table)
        ;

        const cache = this.cacheTable.get(table)

        if (cache === undefined) {
            const result = await this.getColumsBanco(table)
            
            if (result.errorID !== undefined) {
                return result
            }

            this.cacheTable.set(table, {
                coluns: result,
                date: new Date()
            })

            return result
        }

        const ttl = (+(Plata.config._PLATA_SQL_CACHETABLETIME || 60) || 60) * 60 * 1000 

        if ((new Date().getTime() - cache.date.getTime()) > ttl) {
            const result = await this.getColumsBanco(table)
            
            if (result.errorID !== undefined) {
                return result
            }

            this.cacheTable.set(table, {
                coluns: result,
                date: new Date()
            })

            return result
        }

        return cache.coluns
    }

    public async getColumsBanco(table: string): PlataPromise<Record<string | number | symbol, Knex.ColumnInfo>> {
        return this.conn(table).columnInfo().catch(
            err => Plata.BuildPlataError({
                errorID: 'PLSQL004',
                msg: 'Erro ao consultar a estrutura da tabela',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            })
        )
    }

    private getDefaultValue(type: string, value: any | null): any {
        if (value !== null) {
            return value
        }

        switch (type) {
            case 'image':
                return ''
            case 'int':
            case 'integer':
                return 0
            case 'datetime2':
                return null
            case 'decimal':
                return 0
            case 'varbinary':
                return ''
            case 'text':
                return ''
            case 'smallint':
                return 0
            case 'datetimeoffset':
                return 0
            case 'varchar':
                return ''
            case 'binary':
                return 0
            case 'datetime':
                return null
            case 'time':
                return null
            case 'numeric':
                return 0
            case 'uniqueidentifier':
                return 0
            case 'tinyint':
                return 0
            case 'nchar':
                return ''
            case 'smalldatetime':
                return null
            case 'float':
                return 0
            case 'date':
                return null
            case 'char':
                return ''
            case 'bigint':
                return 0
            case 'nvarchar':
                return ''
            case 'sysname':
                return ''
            case 'bit':
                return 0
            default:
                return ''
        }
    }

    public async autoInsert<T extends Model.Template, C extends Model.Converters<T>>(table: string, model: ModelTemplate<T, C>, values: (Model.ParcialTemplateType<T>)[], ignore: StringKeyOfObject<T>[], options?: Sql.InsertOptions): PlataPromise<Model.ExtractTemplateType<T>[]> {
        const columns = await this.getColumns(table)

        if (columns.errorID !== undefined) {
            return columns
        }

        const newValues: any[] = []

        for (let i = 0; i < values.length; i++) {
            const v = Object.create(null)
            
            for (const key in values[i]) {
                v[key.toUpperCase()] = values[i][key]
            }

            const insertValues = Object.create(null)

            for (const key in columns) {
                const n = key.toUpperCase()

                if (ignore.find(c => c.toString().toUpperCase() === n) !== undefined) {
                    continue
                }

                const value = this.getDefaultValue(
                    columns[key].type.toLowerCase(),
                    v[n] ?? null
                )

                if (value === null) {
                    continue
                }

                insertValues[n] = value
            }

            newValues.push(insertValues)
        }

        const inserted: PlataResult<any[]> = await this.insert(
            table, 
            {} as any,
            newValues,
            options,
        )

        if (inserted.errorID !== undefined) {
            return inserted
        }

        const insertedRows: any[] = []

        for (let i = 0; i < inserted.length; i++) {
            const item = inserted[i];

            const insertedRow = Object.create(null)

            for (const key in item) {
                insertedRow[key.toUpperCase()] = item[key]
            }

            insertedRows.push(insertedRow)
        }

        return insertedRows
    }
}

export class Query<T extends Model.Template, C extends Model.Converters<T>> {
    public query: Sql.ModelQueryBuilder<T>
    public readonly model: ModelTemplate<T, C>
    public readonly table: string
    public readonly joins: string[]

    constructor (query: Sql.ModelQueryBuilder<T>, model: ModelTemplate<T, C>, table: string) {
        const context = query.queryContext() ?? Object.create(null)

        this.joins = context._joins ?? []

        this.table = table
        this.model = model
        this.query = this._buildSelect(query, this.model.template)
    }

    private _buildSelect<T extends Model.Template>(query: Sql.ModelQueryBuilder<T>, template: T): Sql.ModelQueryBuilder<T> {
        const cs: string[] = []

        for (const key in template) {
            if (!Array.isArray(template[key])) {
                continue
            }

            if (Array.isArray(template[key][0])) {
                continue
            }

            if (typeof template[key][0] === 'function') {
                cs.push(`${this.table}.${key} as ${this.table}_${key}`)
                continue
            }

            if (!this.joins.includes(key)) {
                continue
            }

            for (const column in template[key][0]) {
                cs.push(`${key}.${column} as ${key}_${column}`)
            }
        }

        return query.select(...cs)
    }
 
    private _buildModel<T extends Model.Template>(row: any): typeof this.model.type {
        const template = this.model.template
        const r: typeof this.model.type = Object.create(null) as any

        for (const key in template) {
            if (!Array.isArray(template[key])) {
                continue
            }

            if (Array.isArray(template[key][0])) {
                r[key] = [] as any
                continue
            }

            if (typeof template[key][0] === 'function') {
                r[key] = row[`${this.table}_${key}`] ?? null
                continue
            }

            if (!this.joins.includes(key)) {
                r[key] = [] as any
                continue
            }

            r[key] = [Object.create(null)] as any

            for (const column in template[key][0]) {
                r[key][0][column] = row[`${key}_${column}`] ?? null
            }
        }

        return r
    }

    public _handleStream<Y>(handler: Sql.StreamHandler): PlataPromise<Y> {
        return new Promise(resolve => {
            let shoudContinue = true

            const stream = this.query.stream()

            stream.on('close', async () => {
                return resolve(handler.close<Y>())
            })

            stream.on('data', async row => {
                if (shoudContinue) {
                    shoudContinue = await handler.row(this._buildModel(row))
                } else {
                    stream.pause()
                }
            })

            stream.on('pause', () => {
                stream.destroy()
            })

            stream.on('error', async err => {
                shoudContinue = false

                if (handler.error !== undefined) await handler.error(err)

                return resolve({
                    errorID: 'PLSQLQ001',
                    msg: 'Unexpected error in query',
                    error: {
                        message: err?.toString(),
                        stack: err?.stack ?? new Error().stack
                    }
                })
            })
        })
    }

    public async toListAsync(): Sql.ModelList<T> {
        const errors: PlataError[] = []
        const itens: any[] = []

        const result: PlataResult<boolean[]> = await this.query.then(
            r => {
                const promises: Promise<boolean>[] = []

                for (let i = 0; i < r.length; i++) {
                    promises.push(Plata.FastPromise(async () => {
                        const v = await this.model.validate(this._buildModel(r[i]))

                        if (v.errors !== undefined) {
                            errors.push(...v.errors)
                        }

                        itens.push(v.value)

                        return true
                    }))
                }

                return Promise.all(promises)
            },
            err => Plata.BuildPlataError({
                errorID: 'PLSQLQ005',
                msg: 'Erro ao execultar a query',
                error: {
                    message: err?.toString(),
                    stack: err?.stack ?? new Error().stack
                }
            })
        )

        if (result.errorID !== undefined) {
            return result
        }

        if (errors.length !== 0) {
            return {
                errors,
                itens,
            }
        }

        return {
            errors: undefined,
            itens,
        }
    }

    public async eachRowAsync(c: Sql.EachRowCallBack<T>): PlataPromise<boolean> {
        const promises: Promise<void>[] = []
        let shoudContinue = true
        let error: PlataError | undefined = undefined

        return this._handleStream<MaybePlataError>({
            row: async row => {
                promises.push(Plata.FastPromise(() => this.model.validate(row))
                    .then(
                        lineResult => {
                            c(lineResult).then(r => {
                                if (r.errorID !== undefined) {
                                    shoudContinue = false
                                    error = r
                                    return
                                }

                                shoudContinue = shoudContinue ? r : shoudContinue
                            })
                        }
                    )
                    .catch(err => {
                        shoudContinue = false
                        error = {
                            errorID: 'PLSQLQ003',
                            msg: 'Unexpected error in callback',
                            error: {
                                message: err?.toString(),
                                stack: err?.stack ?? new Error().stack
                            }
                        }
                    })
                )

                return shoudContinue
            },
            close: async (): PlataPromise<boolean> => {
                return Promise.all(promises).then(
                    () => error ?? true,
                    err => Plata.BuildPlataError({
                        errorID: 'PLSQLQ004',
                        msg: 'Unexpected Error in select',
                        error: err
                    })
                )
            }
        })
    }
}