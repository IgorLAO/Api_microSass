import path from 'node:path'
import fs from 'node:fs'
import readline from 'node:readline'
import * as tGlob from 'glob'
// TODO matar esse aquivo e usar o PlataFS

const glob = (tGlob as any).default as typeof tGlob

export interface PlataError {
    errorID: string,
    msg: string,
    error?: any
}

export type PlataResultado<T> = (T & { errorID?: undefined }) | PlataError 

export namespace PlataDirs {
    export function getProjectDir(): string {
        return path.resolve('.')
    }

    export function getProjectDirTasks(): string {
        return path.resolve('.', 'tasks')
    }

    export function getProjectDirSwagger(): string {
        return path.resolve('.', 'swagger')
    }

    export function getProjectDirSwaggerRotas(): string {
        return path.resolve('.', 'swagger', 'rotas')
    }

    export function getProjectDirClusters(): string {
        return path.resolve('.', 'clusters')
    }

    export function getProjectDirConfig(): string {
        return path.resolve('.', 'configs')
    }

    export function getProjectConfigFileDir(file: string): string {
        return path.resolve('.', 'configs', file).replace(/\\/g, '/')
    }

    export function getProjectDirEnvs(): string {
        return path.resolve('.', 'envs')
    }

    export function getProjectEnvFileDir(file: string): string {
        return path.resolve('.', 'envs', file)
    }

    export function getProjectRoutesDir(): string {
        return path.resolve('.', 'routes')
    }

    export function getPlataTempletesDir(): string {
        return path.join(Plata.PlataDir, 'templates')
    }

    export function getPlataTempleteDir(group:string, ...template: string[]) {
        return path.join(getPlataTempletesDir(), group, ...template)
    }

    export function getPlataBinExtraFile(file: string): string {
        return `${path.join(Plata.ProjectJson, 'bin', 'extras', file)}`.replace(/\\/g, '/')
    }

}

export namespace PlataFiles {
    export type readLineCallback = (line: string) => Promise<void>

    export type readLineCallbackSync = (line: string) => string

    export function readFileAsync(file: string, callback: readLineCallback): Promise<Error | null> {
        return new Promise(resolve => {
            try {
                const promises: any = []

                const stream = readline.createInterface({
                    input: fs.createReadStream(file),
                    crlfDelay: Infinity
                })

                stream.on('close', () => {
                    Promise.all(promises).then(
                        () => resolve(null),
                        (err) => resolve(err),
                    )
                })

                stream.on('line', (line) => {
                    promises.push(callback(line))
                })
            } catch (e) {
                resolve(e)
            }
        })
    }

    export function readFileSync(file: string, callback: readLineCallbackSync): Promise<string | { err: any }> {
        return new Promise(resolve => {
            try {
                const content: string[] = []
                const stream = readline.createInterface({
                    input: fs.createReadStream(file),
                    crlfDelay: Infinity
                })

                stream.on('close', () => {
                    resolve(content.join('\n'))
                })

                stream.on('line', (line) => {
                    content.push(callback(line))
                })

            } catch(e) {
                resolve({ err: e })
            }
        })
    }

    export async function findFile(folders: string[], file: string): Promise<string | null> {
        for (const folder of folders) {
            const f = glob.sync(`${folder.replace(/\\/g, '/')}/**/${file.toLowerCase()}*`)[0]

            if (f !== undefined) {
                return f
            }
        }

        return null
    }

    export async function findFiles(folders: string[], file: string): Promise<string[]> {
        const files: string[] = []

        for (const folder of folders) {            
            files.push(...glob.sync(`${folder.replace(/\\/g, '/')}/**/${file}`))
        }

        return files
    } 

    export async function createFileIfNotExists(filePath: string, content: string): Promise<PlataResultado<string>> {
        const p = path.resolve(filePath)

        if (!fs.existsSync(p)) {
            return createFile(filePath, content)
        }

        return p
    }

    export async function createFile(filePath: string, content: string): Promise<PlataResultado<string>> {
        try {
            const p = path.resolve(filePath)

            fs.mkdirSync(path.dirname(p), { recursive: true })
            fs.writeFileSync(p, content)

            return p
        } catch (e) {
            return {
                errorID: 'PLTPF0001',
                msg: `Erro ao criar ao criar o arquivo ${filePath}`,
                error: e
            }
        }
        
    }

    export function readJsonSync(filePath: string): any {
        return JSON.parse(fs.readFileSync(filePath).toString())
    }
}

export namespace PlataRequire {
    export type Required<Type> = PlataResultado<RequiredInterface<Type>>
    export interface RequiredInterface<Type> {
        filePath: string,
        name: string,
        exports: Type
    }

    export async function requireAsync<Type>(file: string): Promise<Required<Type>> {
        const p = path.resolve(file)

        const e = await import(p.replace(/\\/g, '/')).catch(e => { return {_plataError: e }  })

        if (e._plataError !== undefined) {
            return {
                errorID: 'PLTRF0001',
                msg: `Erro ao importar o arquivo ${file}`,
                error: e._plataError
            }
        }

        return {
            filePath: p,
            name: path.basename(p).replace('.ts', '').replace('.js', ''),
            exports: e.default as Type
        }
    }

    export async function requireFolderAsync<Type>(folder: string): Promise<PlataResultado<Required<Type>[]>> {
        const promises: Promise<Required<Type>>[] = []
        const p = path.resolve(folder)

        glob.sync(`${p.replace(/\\/g, '/')}/**/*.+(js|ts)`)
            .filter(file => !file.endsWith('.d.ts'))
            .forEach(file => {
                file = file.replace(/\.ts|\.js$/, '')

                promises.push(requireAsync<Type>(file))
            })

        return Promise.all(promises).catch(
            e => {
                return {
                    errorID: 'PLTRF0002',
                    msg: `Erro ao importar a pasta ${folder}`,
                    error: e
                }
            }
        )
    }
}

export namespace PlataExtra {
    export function sleep(ms: number) {
        return new Promise(resolve => setTimeout(resolve, ms))
    }
}