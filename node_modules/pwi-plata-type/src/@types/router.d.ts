/// <reference types="express" />

import express from 'express'

declare global {
    namespace Router {
        type ListRouteParams<TRoute extends string> =
            TRoute extends `/${infer TPart}/${infer TNextRoute}` ?
                TPart extends `:${infer TParam}?` ? `${TParam}_O` | ListRouteParams<`/${TNextRoute}`>
                : TPart extends `:${infer TParam}` ? `${TParam}_R` | ListRouteParams<`/${TNextRoute}`>
                : undefined | ListRouteParams<`/${TNextRoute}`>
            : TRoute extends `/${infer TPart}` ?
                TPart extends `:${infer TParam}?` ? `${TParam}_O`
                : TPart extends `:${infer TParam}` ? `${TParam}_R`
                : undefined
            : undefined
        ;   

        type GetRouteParams<TRoute extends string> = Exclude<ListRouteParams<TRoute>, undefined>

        type GetUrlParams<TRoute extends string, TParams extends string = GetRouteParams<TRoute>> = {
            [K in LooseAutocomplete<TParams> as K extends `${infer N}_${string}` ? N : string]: K extends `${string}_O` ? string | undefined : string
        }

        type expressRequest = Omit<express.Request, 'params'>

        interface Request<T extends string = string> extends expressRequest {
            user: any
            extras: any
            _onResponseEvent: PlataOnResponseEvent[]
            params: GetUrlParams<T>
        }

        interface Response extends express.Response {
            oldJson(body?: any): this
            error(error: PlataError | PlataError[]): this
            addOnResponseEvent<T = any>(callback: PlataOnResponseEvent<T>): void
        }

        type RequestHandler<T extends string = string> = (req: Request<T>, res: Response, next: express.NextFunction) => Promise<any>

        type HttpPlataMethods =
            "all"
            | "get"
            | "post"
            | "put"
            | "delete"
            | "patch"
            | "options"
            | "head"
            | "checkout"
            | "connect"
            | "copy"
            | "lock"
            | "merge"
            | "mkactivity"
            | "mkcol"
            | "move"
            | "notify"
            | "propfind"
            | "proppatch"
            | "purge"
            | "report"
            | "search"
            | "subscribe"
            | "trace"
            | "unlock"
            | "unsubscribe"
            | "use"
        ;

        interface CustomHttpMethods {}

        type HttpMethods = 
            HttpPlataMethods
            | keyof CustomHttpMethods
        ;

        interface Route {
            path?: string
            method: string
            handlers: RequestHandler[],
            swaggerHide?: boolean | undefined
        }

        type RouterConfig<T extends Record<string, unknown> = Record<string, unknown>> = {
            swaggerHide?: boolean
            routes: Route[]
            httpRoute: string
            mark: T
        }

        type Router = RouterConfig & {
            [method in HttpMethods]: 
                method extends keyof CustomHttpMethods ?
                CustomHttpMethods[method]
                : <T extends string>(path: T | RequestHandler, ...handlers: RequestHandler<T>[]) => void | Promise<void>
        }

        type RouterBuilder = (r: Router) => Promise<Router>

        export interface RequiredRoute extends RequiredInterface<RouterBuilder> {
            httpRoute: string
        }

        type PlataOnResponseEvent<T = any> = (aReq: Request, aRes?: Response, body?: T, error?: PlataError | PlataError[]) => Promise<any>
    }
}