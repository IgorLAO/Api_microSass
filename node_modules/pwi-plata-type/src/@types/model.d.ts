declare namespace Model {

    type ValidateReturn = PlataError | null

    interface PrimitiveValidationTypeReturn {
        error?: PlataError
        continua: boolean
    }

    type PrimitiveValidationTypeFunction<T = any, D = undefined> = 
        (nome: string, valor: T | D) => Promise<PrimitiveValidationTypeReturn>
    ;


    interface PrimitiveValidationType<T = any, D = undefined> extends PrimitiveValidationTypeFunction<T, D>{
        filter?: (value: any) => any
    }

    interface Template {
        readonly [name: string]: 
            readonly PrimitiveValidationType<unknown, unknown>[] |
            readonly Template[] |
            Template |
            readonly (readonly PrimitiveValidationType[])[]
    }

    interface TemplateEnv {
        readonly [name: string]: readonly PrimitiveValidationType<unknown, unknown>[] 
    }

    type GetTemplateParamType<T> = 
        T extends readonly [ PrimitiveValidationType<infer G, infer H> ] ? G | H :
        T extends readonly [ PrimitiveValidationType<any, infer H>,  PrimitiveValidationType<infer G, any> ] ? G | H :
        T extends readonly [ PrimitiveValidationType<any, infer H>,  ...any[], PrimitiveValidationType<infer G, any> ] ? G | H :
        never
    ;

    type GetTemplateEnvParamType<const T extends PrimitiveValidationType<unknown, unknown>[]> =
        T extends readonly [ PrimitiveValidationType<infer G, infer H> ] ? `${G}` | H :
        T extends readonly [ PrimitiveValidationType<any, infer H>,  PrimitiveValidationType<infer G, any> ] ? `${G}` | H :
        T extends readonly [ PrimitiveValidationType<any, infer H>,  ...any[], PrimitiveValidationType<infer G, any> ] ? `${G}` | H :
        never
    ;

    type ExtractTemplateParamType<T> = Exclude<GetTemplateParamType<T>, undefined>

    type ExtractTemplateEnvParamType<const T> = Replace<Exclude<GetTemplateEnvParamType<T>, undefined>, null, undefined>

    type ExtractTemplateType<T extends Template> = {
        [P in keyof T]: T[P] extends Template ? ExtractTemplateType<T[P]> : 
                        T[P] extends readonly Template[] ? ExtractTemplateType<T[P][0]>[] :
                        T[P] extends readonly (readonly PrimitiveValidationType[])[] ? ExtractTemplateParamType<T[P][0]>[] : 
                        T[P] extends readonly PrimitiveValidationType<unknown, unknown>[] ? ExtractTemplateParamType<T[P]> :
                        number | boolean | string | null
    }


    type ExtractTemplateEnvType<const T extends TemplateEnv> = {
        [P in keyof T]: ExtractTemplateEnvParamType<T[P]>
    }

    type ExtractTemplateTypeNotValid<T extends Template> = {
        [P in keyof T]: T[P] extends Template ? ExtractTemplateTypeNotValid<T[P]> : 
                        T[P] extends readonly Template[] ? ExtractTemplateTypeNotValid<T[P][0]>[] :
                        T[P] extends readonly (readonly PrimitiveValidationType[])[] ? (number | boolean | string | null)[] :
                        number | boolean | string | null
    }

    type ParcialTemplateType<T extends Template> = Partial<ExtractTemplateType<T>>

    type ModelTemplateValidation<T extends Template> = (value: ExtractTemplateType<T>) => Promise<PlataError | null>

    type ModelTemplateFilter<T extends Template> = (value: DeepWritable<ExtractTemplateTypeNotValid<T>>) => DeepWritable<ExtractTemplateTypeNotValid<T>>

    type ModelTemplateEnvValidation<const T extends TemplateEnv> = (value: ExtractTemplateEnvType<T>) => Promise<PlataError | null>

    type ModelValidateReturn<T extends Template> =
        ModelValidateReturnHelper<ExtractTemplateType<T>, ExtractTemplateTypeNotValid<T>>
    ;

    type ModelValidateEnvReturn<const T extends TemplateEnv> = 
        ModelValidateReturnHelper<ExtractTemplateEnvType<T>, undefined>
    ;

    type ModelValidateReturnHelper<const OKAY, const ERROR> = 
        | {
            errors: undefined,
            value: OKAY
        }
        | {
            errors: PlataError[]
            value: ERROR
        }
    ;

    type ConvertFunction<T extends Template, O> = (x: ExtractTemplateType<T>) => O

    type Converters<T extends Template> = (AnyRecord<Model.ConvertFunction<T, any>>)

    type GetConverterType<T extends Template, F> = F extends ConvertFunction<T, infer G> ? G : never

    type ModelConvertFuntion<T extends Template, C extends Converters<T>> =
        <K extends keyof C>(value: ExtractTemplateType<T>, to: K) => PlataResult<GetConverterType<T, C[K]>>
    ;

    interface TemplateUnionConfig {
        key: string
    }

    interface ModelClass {
        readonly type: Record<string | number, any>
        filter?: (value: any) => any 
        validate(value: any, skipFilter?: true): Promise<Model.ModelValidateReturnHelper<any, any>>

    }
    
    type TemplateRecord = 
        Record<string | `${number}` | `${boolean}` | 'null', ModelClass>
    ;

    type ExtractModelUnionType<const C extends TemplateUnionConfig, const R extends TemplateRecord> = {
        [K in keyof R]: Record<C['key'], K> & R[K]['type']
    }[keyof R]
    
    type RemoveTypesForFilter<T extends Record<string, any>> = {
        -readonly [K in keyof T]: 
            T[K] extends Record<string, any> ? RemoveTypesForFilter<T[K]>
        : number | boolean | string | null
        
    } 

    type ExtractModelUnionTypeFilter<const C extends TemplateUnionConfig, const R extends TemplateRecord> = {
        [K in keyof R]: Record<C['key'], K> & RemoveTypesForFilter<R[K]['type']>
    }[keyof R]

    type ExtractModelUnionReturn<const C extends TemplateUnionConfig, const R extends TemplateRecord> = 
        {
            [K in keyof R]: {
                model: R[K],
                value: R[K]['type'] & Record<C['key'], K>
            }
        }[keyof R]
    ;
}